diff --git a/server.js b/server.js
index 7ba16d7..2f0ff16 100644
--- a/server.js
+++ b/server.js
@@ -118,17 +118,95 @@ app.put('/api/v1/clients/:id', (req, res) => {
   const id = parseInt(req.params.id , 10);
   const { valid, messageObj } = validateId(id);
   if (!valid) {
-    res.status(400).send(messageObj);
+    return res.status(400).send(messageObj);
   }
 
   let { status, priority } = req.body;
-  let clients = db.prepare('select * from clients').all();
-  const client = clients.find(client => client.id === id);
+  const client = db.prepare('select * from clients where id = ? limit 1').get(id);
+
+  const oldStatus = client.status;
+  const oldPriority = client.priority;
 
-  /* ---------- Update code below ----------*/
+  // 如果沒給 status，預設維持原本的 status
+  if (!status) {
+    status = oldStatus;
+  }
+
+  // 驗證 status 是否合法
+  if (status !== 'backlog' && status !== 'in-progress' && status !== 'complete') {
+    return res.status(400).send({
+      'message': 'Invalid status provided.',
+      'long_message': 'Status can only be one of the following: [backlog | in-progress | complete].',
+    });
+  }
 
+  // 如果 priority 有給，驗證它
+  if (priority) {
+    priority = parseInt(priority, 10);
+    const { valid, messageObj } = validatePriority(priority);
+    if (!valid) {
+      return res.status(400).send(messageObj);
+    }
+  }
+
+  // 情境：status 沒變，也沒指定新的 priority → 什麼都不做
+  if (status === oldStatus && !priority) {
+    const clients = db.prepare('select * from clients').all();
+    return res.status(200).send(clients);
+  }
+
+  // 情境：status 沒變，但 priority 改變了（同泳道重排）
+  if (status === oldStatus && priority) {
+    if (priority === oldPriority) {
+      // priority 也沒變，什麼都不做
+      const clients = db.prepare('select * from clients').all();
+      return res.status(200).send(clients);
+    }
+
+    // 同泳道內重新排列
+    if (oldPriority < priority) {
+      // 卡片往下移（priority 變大）
+      // 原本在 oldPriority+1 ~ newPriority 之間的卡片，priority 各 -1
+      db.prepare(
+        'UPDATE clients SET priority = priority - 1 WHERE status = ? AND priority > ? AND priority <= ?'
+      ).run(status, oldPriority, priority);
+    } else {
+      // 卡片往上移（priority 變小）
+      // 原本在 newPriority ~ oldPriority-1 之間的卡片，priority 各 +1
+      db.prepare(
+        'UPDATE clients SET priority = priority + 1 WHERE status = ? AND priority >= ? AND priority < ?'
+      ).run(status, priority, oldPriority);
+    }
+
+    // 更新該卡片的 priority
+    db.prepare('UPDATE clients SET priority = ? WHERE id = ?').run(priority, id);
+
+    const clients = db.prepare('select * from clients').all();
+    return res.status(200).send(clients);
+  }
+
+  // 情境：status 改變了（跨泳道移動）
+  // Step 1: 從舊泳道移除 → 舊泳道中 priority > oldPriority 的卡片 priority 各 -1
+  db.prepare(
+    'UPDATE clients SET priority = priority - 1 WHERE status = ? AND priority > ?'
+  ).run(oldStatus, oldPriority);
+
+  // Step 2: 決定在新泳道的 priority
+  if (!priority) {
+    // 沒有指定 priority → 放到新泳道的最後面
+    const result = db.prepare('SELECT MAX(priority) as max FROM clients WHERE status = ?').get(status);
+    priority = (result.max || 0) + 1;
+  } else {
+    // 有指定 priority → 新泳道中 priority >= newPriority 的卡片 priority 各 +1（騰出位置）
+    db.prepare(
+      'UPDATE clients SET priority = priority + 1 WHERE status = ? AND priority >= ?'
+    ).run(status, priority);
+  }
 
+  // Step 3: 更新該卡片的 status 和 priority
+  db.prepare('UPDATE clients SET status = ?, priority = ? WHERE id = ?').run(status, priority, id);
 
+  const clients = db.prepare('select * from clients').all();
   return res.status(200).send(clients);
 });
 
